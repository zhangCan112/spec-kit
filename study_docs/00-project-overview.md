# 00 - 项目概览与核心理念

## 📖 Spec Kit 是什么？

**GitHub Spec Kit** 是一个开源工具包，用于实现**规范驱动开发**方法。它允许开发团队专注于产品场景和可预测的结果，而不是从零开始编写每一行代码。

### 核心定位

Spec Kit 不是另一个代码生成器，而是一个**结构化的开发方法论和工具集**，其核心思想是：

> **规范是第一性的，代码是从规范衍生的。**

### 解决的核心问题

传统软件开发中存在几个长期存在的问题：

| 问题 | 传统方式 | SDD 方式 |
|------|----------|----------|
| **规范与代码分离** | PRD 和代码是两套东西，容易不同步 | 规范直接生成代码，始终保持同步 |
| **需求变更困难** | 每次变更需要手动更新文档、设计、代码 | 修改规范，自动重新生成 |
| **技术债积累** | 快速迭代往往牺牲代码质量 | 通过约束和模板保证质量 |
| **知识传递困难** | 开发者离职后，项目难以理解 | 规范本身就是完整的知识库 |

---

## 🎯 Spec-Driven Development (SDD) 方法论

### 核心理念

SDD 彻底改变了软件开发的权力结构：

```
传统方式: 代码 → 规范（代码是第一性的）
SDD 方式:  规范 → 代码（规范是第一性的）
```

### 九大基本原则

#### Article I: Library-First 原则
每个功能必须先作为独立库存在，然后才能集成到应用中。

#### Article II: CLI 接口强制要求
所有库必须通过命令行接口暴露功能：
- 接受文本输入（stdin、参数或文件）
- 产生文本输出（stdout）
- 支持 JSON 格式的结构化数据交换

#### Article III: 测试优先的强制性
这是**不可协商的**：所有实现必须遵循严格的测试驱动开发：
1. 先编写单元测试
2. 测试必须经过用户验证并批准
3. 测试必须确认失败（Red 阶段）
4. 然后才能编写实现代码

#### Article IV: 可观察性原则
所有功能都必须是可观察和可验证的。

#### Article V: 最小化原则
从最小的可行实现开始，只在实际需要时添加复杂性。

#### Article VI: 原子性原则
每次提交都应该是原子性的、完整的。

#### Article VII: 简单性原则
- 初始实现最多 3 个项目
- 不进行未来防护（future-proofing）

#### Article VIII: 反抽象原则
- 直接使用框架特性
- 单一模型表示

#### Article IX: 集成优先测试
- 优先使用真实数据库而非模拟
- 使用实际服务实例而非桩代码
- 实现前必须进行契约测试

---

## 🔑 项目核心价值

### 1. 意图驱动开发

开发团队的意图通过自然语言表达，代码只是最后一英里的实现。

### 2. 可执行规范

规范必须足够精确、完整和明确，能够生成可工作的系统。

### 3. 持续细化

一致性验证是持续进行的，而非一次性检查。

### 4. 研究驱动上下文

在规范过程中持续收集技术上下文。

### 5. 双向反馈

生产现实影响规范演进。指标、事故和运营学习成为规范细化的输入。

---

## 🌟 开发流程

### 完整工作流

```
┌─────────────────────────────────────────────────────────────────┐
│                      Constitution（项目宪章）                      │
│                   定义项目的核心开发原则                          │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   /speckit.constitution                          │
│              创建或更新项目治理原则和开发准则                     │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   /speckit.specify                               │
│              创建功能规范（定义 WHAT 和 WHY）                      │
│              - 创建 Git 分支                                      │
│              - 生成 specs/XXX-feature/spec.md                    │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ▼
                    [可选] /speckit.clarify
                      明确模糊的需求区域
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   /speckit.plan                                  │
│            创建技术实现计划（定义 HOW）                            │
│            - 技术栈选择                                           │
│            - 架构设计                                             │
│            - 生成 research.md, data-model.md, contracts/         │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   /speckit.tasks                                 │
│            将计划分解为可执行的任务列表                            │
│            - 按用户故事组织任务                                    │
│            - 标记依赖关系和并行执行                               │
└─────────────────────────────────────────────────────────────────┘
                            │
                            ▼
            [可选] /speckit.analyze (交叉一致性分析)
            [可选] /speckit.checklist (质量检查清单)
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                   /speckit.implement                             │
│            执行所有任务，按照计划构建功能                          │
└─────────────────────────────────────────────────────────────────┘
```

---

## 🚀 支持的开发阶段

### 0-to-1 开发
从零开始生成应用：
- 从高层需求开始
- 生成规范
- 规划实现步骤
- 构建生产就绪的应用

### 创意探索
并行实现：
- 探索多样化的解决方案
- 支持多种技术栈和架构
- 实验不同的 UX 模式

### 迭代增强
旧系统现代化：
- 迭代添加功能
- 现代化遗留系统
- 适应流程变化

---

## 💡 为什么 SDD 现在重要？

三个趋势使 SDD 不仅可能，而且必要：

### 1. AI 能力达到阈值
AI 现在能够可靠地将自然语言规范转换为工作代码。这取代开发者，而是放大他们的效率。

### 2. 软件复杂性指数级增长
现代系统集成了数十个服务、框架和依赖。通过手动流程保持所有这些与原始意图的对齐变得越来越困难。SDD 通过规范驱动生成提供系统化对齐。

### 3. 变化速度加快
需求变化比以往任何时候都快。转向不再是例外，而是预期。现代产品开发需要基于用户反馈、市场条件和竞争压力的快速迭代。

---

## 📦 项目组件

### Specify CLI
用于引导 Spec-Driven Development 项目的命令行工具。

### 模板系统
- 命令模板（`templates/commands/*.md`）
- 规范模板（`templates/spec-template.md`）
- 计划模板（`templates/plan-template.md`）
- 任务模板（`templates/tasks-template.md`）

### 自动化脚本
- Bash 脚本（`scripts/bash/`）
- PowerShell 脚本（`scripts/powershell/`）
- 跨平台支持

### AI 代理集成
支持 18+ 种 AI 编码助手（Claude、Gemini、Cursor、Copilot 等）

---

## 🎓 学习路径建议

1. **从概览开始**（本文档）- 理解 SDD 理念
2. **学习架构**（01-architecture-and-design.md）- 理解项目结构
3. **深入 CLI**（02-cli-implementation-guide.md）- 理解核心实现
4. **掌握工作流**（03-sdd-workflow-explained.md）- 理解流程
5. **研究模板**（04-templates-and-prompts-system.md）- 理解约束机制
6. **实践扩展**（09-extending-and-contributing.md）- 学习如何贡献

---

## 📚 相关资源

- [GitHub 仓库](https://github.com/github/spec-kit)
- [官方文档](https://github.github.io/spec-kit/)
- [视频教程](https://www.youtube.com/watch?v=a9eR1xsfvHg)
- [SDD 方法论文档](../spec-driven.md)